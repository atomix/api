// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/primitive/indexedmap/indexedmap.proto

package indexedmap

import (
	context "context"
	fmt "fmt"
	primitive "github.com/atomix/api/go/atomix/primitive"
	meta "github.com/atomix/api/go/atomix/primitive/meta"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventsOutput_Type int32

const (
	EventsOutput_NONE     EventsOutput_Type = 0
	EventsOutput_INSERTED EventsOutput_Type = 1
	EventsOutput_UPDATED  EventsOutput_Type = 2
	EventsOutput_REMOVED  EventsOutput_Type = 3
)

var EventsOutput_Type_name = map[int32]string{
	0: "NONE",
	1: "INSERTED",
	2: "UPDATED",
	3: "REMOVED",
}

var EventsOutput_Type_value = map[string]int32{
	"NONE":     0,
	"INSERTED": 1,
	"UPDATED":  2,
	"REMOVED":  3,
}

func (x EventsOutput_Type) String() string {
	return proto.EnumName(EventsOutput_Type_name, int32(x))
}

func (EventsOutput_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{47, 0}
}

type ExistsRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  ExistsInput             `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *ExistsRequest) Reset()         { *m = ExistsRequest{} }
func (m *ExistsRequest) String() string { return proto.CompactTextString(m) }
func (*ExistsRequest) ProtoMessage()    {}
func (*ExistsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{0}
}
func (m *ExistsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExistsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExistsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExistsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistsRequest.Merge(m, src)
}
func (m *ExistsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExistsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExistsRequest proto.InternalMessageInfo

func (m *ExistsRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *ExistsRequest) GetInput() ExistsInput {
	if m != nil {
		return m.Input
	}
	return ExistsInput{}
}

type ExistsInput struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ExistsInput) Reset()         { *m = ExistsInput{} }
func (m *ExistsInput) String() string { return proto.CompactTextString(m) }
func (*ExistsInput) ProtoMessage()    {}
func (*ExistsInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{1}
}
func (m *ExistsInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExistsInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExistsInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExistsInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistsInput.Merge(m, src)
}
func (m *ExistsInput) XXX_Size() int {
	return m.Size()
}
func (m *ExistsInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistsInput.DiscardUnknown(m)
}

var xxx_messageInfo_ExistsInput proto.InternalMessageInfo

func (m *ExistsInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type ExistsResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output ExistsOutput             `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *ExistsResponse) Reset()         { *m = ExistsResponse{} }
func (m *ExistsResponse) String() string { return proto.CompactTextString(m) }
func (*ExistsResponse) ProtoMessage()    {}
func (*ExistsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{2}
}
func (m *ExistsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExistsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExistsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExistsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistsResponse.Merge(m, src)
}
func (m *ExistsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExistsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExistsResponse proto.InternalMessageInfo

func (m *ExistsResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *ExistsResponse) GetOutput() ExistsOutput {
	if m != nil {
		return m.Output
	}
	return ExistsOutput{}
}

type ExistsOutput struct {
	ContainsKey bool `protobuf:"varint,1,opt,name=contains_key,json=containsKey,proto3" json:"contains_key,omitempty"`
}

func (m *ExistsOutput) Reset()         { *m = ExistsOutput{} }
func (m *ExistsOutput) String() string { return proto.CompactTextString(m) }
func (*ExistsOutput) ProtoMessage()    {}
func (*ExistsOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{3}
}
func (m *ExistsOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExistsOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExistsOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExistsOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistsOutput.Merge(m, src)
}
func (m *ExistsOutput) XXX_Size() int {
	return m.Size()
}
func (m *ExistsOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistsOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ExistsOutput proto.InternalMessageInfo

func (m *ExistsOutput) GetContainsKey() bool {
	if m != nil {
		return m.ContainsKey
	}
	return false
}

type SizeRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  SizeInput               `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *SizeRequest) Reset()         { *m = SizeRequest{} }
func (m *SizeRequest) String() string { return proto.CompactTextString(m) }
func (*SizeRequest) ProtoMessage()    {}
func (*SizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{4}
}
func (m *SizeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeRequest.Merge(m, src)
}
func (m *SizeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SizeRequest proto.InternalMessageInfo

func (m *SizeRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *SizeRequest) GetInput() SizeInput {
	if m != nil {
		return m.Input
	}
	return SizeInput{}
}

type SizeInput struct {
}

func (m *SizeInput) Reset()         { *m = SizeInput{} }
func (m *SizeInput) String() string { return proto.CompactTextString(m) }
func (*SizeInput) ProtoMessage()    {}
func (*SizeInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{5}
}
func (m *SizeInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeInput.Merge(m, src)
}
func (m *SizeInput) XXX_Size() int {
	return m.Size()
}
func (m *SizeInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeInput.DiscardUnknown(m)
}

var xxx_messageInfo_SizeInput proto.InternalMessageInfo

type SizeResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output SizeOutput               `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *SizeResponse) Reset()         { *m = SizeResponse{} }
func (m *SizeResponse) String() string { return proto.CompactTextString(m) }
func (*SizeResponse) ProtoMessage()    {}
func (*SizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{6}
}
func (m *SizeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeResponse.Merge(m, src)
}
func (m *SizeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SizeResponse proto.InternalMessageInfo

func (m *SizeResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *SizeResponse) GetOutput() SizeOutput {
	if m != nil {
		return m.Output
	}
	return SizeOutput{}
}

type SizeOutput struct {
	Size_ uint32 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *SizeOutput) Reset()         { *m = SizeOutput{} }
func (m *SizeOutput) String() string { return proto.CompactTextString(m) }
func (*SizeOutput) ProtoMessage()    {}
func (*SizeOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{7}
}
func (m *SizeOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeOutput.Merge(m, src)
}
func (m *SizeOutput) XXX_Size() int {
	return m.Size()
}
func (m *SizeOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SizeOutput proto.InternalMessageInfo

func (m *SizeOutput) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type PutRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  PutInput                `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *PutRequest) Reset()         { *m = PutRequest{} }
func (m *PutRequest) String() string { return proto.CompactTextString(m) }
func (*PutRequest) ProtoMessage()    {}
func (*PutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{8}
}
func (m *PutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutRequest.Merge(m, src)
}
func (m *PutRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutRequest proto.InternalMessageInfo

func (m *PutRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *PutRequest) GetInput() PutInput {
	if m != nil {
		return m.Input
	}
	return PutInput{}
}

type PutInput struct {
	Entry   Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry"`
	IfEmpty bool  `protobuf:"varint,2,opt,name=if_empty,json=ifEmpty,proto3" json:"if_empty,omitempty"`
}

func (m *PutInput) Reset()         { *m = PutInput{} }
func (m *PutInput) String() string { return proto.CompactTextString(m) }
func (*PutInput) ProtoMessage()    {}
func (*PutInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{9}
}
func (m *PutInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutInput.Merge(m, src)
}
func (m *PutInput) XXX_Size() int {
	return m.Size()
}
func (m *PutInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PutInput.DiscardUnknown(m)
}

var xxx_messageInfo_PutInput proto.InternalMessageInfo

func (m *PutInput) GetEntry() Entry {
	if m != nil {
		return m.Entry
	}
	return Entry{}
}

func (m *PutInput) GetIfEmpty() bool {
	if m != nil {
		return m.IfEmpty
	}
	return false
}

type PutResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output PutOutput                `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *PutResponse) Reset()         { *m = PutResponse{} }
func (m *PutResponse) String() string { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()    {}
func (*PutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{10}
}
func (m *PutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutResponse.Merge(m, src)
}
func (m *PutResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutResponse proto.InternalMessageInfo

func (m *PutResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *PutResponse) GetOutput() PutOutput {
	if m != nil {
		return m.Output
	}
	return PutOutput{}
}

type PutOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *PutOutput) Reset()         { *m = PutOutput{} }
func (m *PutOutput) String() string { return proto.CompactTextString(m) }
func (*PutOutput) ProtoMessage()    {}
func (*PutOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{11}
}
func (m *PutOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutOutput.Merge(m, src)
}
func (m *PutOutput) XXX_Size() int {
	return m.Size()
}
func (m *PutOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_PutOutput.DiscardUnknown(m)
}

var xxx_messageInfo_PutOutput proto.InternalMessageInfo

func (m *PutOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type GetRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  GetInput                `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{12}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *GetRequest) GetInput() GetInput {
	if m != nil {
		return m.Input
	}
	return GetInput{}
}

type GetInput struct {
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Key   string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetInput) Reset()         { *m = GetInput{} }
func (m *GetInput) String() string { return proto.CompactTextString(m) }
func (*GetInput) ProtoMessage()    {}
func (*GetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{13}
}
func (m *GetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInput.Merge(m, src)
}
func (m *GetInput) XXX_Size() int {
	return m.Size()
}
func (m *GetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInput.DiscardUnknown(m)
}

var xxx_messageInfo_GetInput proto.InternalMessageInfo

func (m *GetInput) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output GetOutput                `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{14}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *GetResponse) GetOutput() GetOutput {
	if m != nil {
		return m.Output
	}
	return GetOutput{}
}

type GetOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *GetOutput) Reset()         { *m = GetOutput{} }
func (m *GetOutput) String() string { return proto.CompactTextString(m) }
func (*GetOutput) ProtoMessage()    {}
func (*GetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{15}
}
func (m *GetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOutput.Merge(m, src)
}
func (m *GetOutput) XXX_Size() int {
	return m.Size()
}
func (m *GetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_GetOutput proto.InternalMessageInfo

func (m *GetOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type FirstEntryRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  FirstEntryInput         `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *FirstEntryRequest) Reset()         { *m = FirstEntryRequest{} }
func (m *FirstEntryRequest) String() string { return proto.CompactTextString(m) }
func (*FirstEntryRequest) ProtoMessage()    {}
func (*FirstEntryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{16}
}
func (m *FirstEntryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstEntryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstEntryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstEntryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstEntryRequest.Merge(m, src)
}
func (m *FirstEntryRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirstEntryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstEntryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirstEntryRequest proto.InternalMessageInfo

func (m *FirstEntryRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *FirstEntryRequest) GetInput() FirstEntryInput {
	if m != nil {
		return m.Input
	}
	return FirstEntryInput{}
}

type FirstEntryInput struct {
}

func (m *FirstEntryInput) Reset()         { *m = FirstEntryInput{} }
func (m *FirstEntryInput) String() string { return proto.CompactTextString(m) }
func (*FirstEntryInput) ProtoMessage()    {}
func (*FirstEntryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{17}
}
func (m *FirstEntryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstEntryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstEntryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstEntryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstEntryInput.Merge(m, src)
}
func (m *FirstEntryInput) XXX_Size() int {
	return m.Size()
}
func (m *FirstEntryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstEntryInput.DiscardUnknown(m)
}

var xxx_messageInfo_FirstEntryInput proto.InternalMessageInfo

type FirstEntryResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output FirstEntryOutput         `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *FirstEntryResponse) Reset()         { *m = FirstEntryResponse{} }
func (m *FirstEntryResponse) String() string { return proto.CompactTextString(m) }
func (*FirstEntryResponse) ProtoMessage()    {}
func (*FirstEntryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{18}
}
func (m *FirstEntryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstEntryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstEntryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstEntryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstEntryResponse.Merge(m, src)
}
func (m *FirstEntryResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirstEntryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstEntryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirstEntryResponse proto.InternalMessageInfo

func (m *FirstEntryResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *FirstEntryResponse) GetOutput() FirstEntryOutput {
	if m != nil {
		return m.Output
	}
	return FirstEntryOutput{}
}

type FirstEntryOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *FirstEntryOutput) Reset()         { *m = FirstEntryOutput{} }
func (m *FirstEntryOutput) String() string { return proto.CompactTextString(m) }
func (*FirstEntryOutput) ProtoMessage()    {}
func (*FirstEntryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{19}
}
func (m *FirstEntryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstEntryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstEntryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstEntryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstEntryOutput.Merge(m, src)
}
func (m *FirstEntryOutput) XXX_Size() int {
	return m.Size()
}
func (m *FirstEntryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstEntryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_FirstEntryOutput proto.InternalMessageInfo

func (m *FirstEntryOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type LastEntryRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  LastEntryInput          `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *LastEntryRequest) Reset()         { *m = LastEntryRequest{} }
func (m *LastEntryRequest) String() string { return proto.CompactTextString(m) }
func (*LastEntryRequest) ProtoMessage()    {}
func (*LastEntryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{20}
}
func (m *LastEntryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastEntryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastEntryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastEntryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastEntryRequest.Merge(m, src)
}
func (m *LastEntryRequest) XXX_Size() int {
	return m.Size()
}
func (m *LastEntryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LastEntryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LastEntryRequest proto.InternalMessageInfo

func (m *LastEntryRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *LastEntryRequest) GetInput() LastEntryInput {
	if m != nil {
		return m.Input
	}
	return LastEntryInput{}
}

type LastEntryInput struct {
}

func (m *LastEntryInput) Reset()         { *m = LastEntryInput{} }
func (m *LastEntryInput) String() string { return proto.CompactTextString(m) }
func (*LastEntryInput) ProtoMessage()    {}
func (*LastEntryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{21}
}
func (m *LastEntryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastEntryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastEntryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastEntryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastEntryInput.Merge(m, src)
}
func (m *LastEntryInput) XXX_Size() int {
	return m.Size()
}
func (m *LastEntryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_LastEntryInput.DiscardUnknown(m)
}

var xxx_messageInfo_LastEntryInput proto.InternalMessageInfo

type LastEntryResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output LastEntryOutput          `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *LastEntryResponse) Reset()         { *m = LastEntryResponse{} }
func (m *LastEntryResponse) String() string { return proto.CompactTextString(m) }
func (*LastEntryResponse) ProtoMessage()    {}
func (*LastEntryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{22}
}
func (m *LastEntryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastEntryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastEntryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastEntryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastEntryResponse.Merge(m, src)
}
func (m *LastEntryResponse) XXX_Size() int {
	return m.Size()
}
func (m *LastEntryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LastEntryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LastEntryResponse proto.InternalMessageInfo

func (m *LastEntryResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *LastEntryResponse) GetOutput() LastEntryOutput {
	if m != nil {
		return m.Output
	}
	return LastEntryOutput{}
}

type LastEntryOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *LastEntryOutput) Reset()         { *m = LastEntryOutput{} }
func (m *LastEntryOutput) String() string { return proto.CompactTextString(m) }
func (*LastEntryOutput) ProtoMessage()    {}
func (*LastEntryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{23}
}
func (m *LastEntryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastEntryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastEntryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastEntryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastEntryOutput.Merge(m, src)
}
func (m *LastEntryOutput) XXX_Size() int {
	return m.Size()
}
func (m *LastEntryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_LastEntryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_LastEntryOutput proto.InternalMessageInfo

func (m *LastEntryOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type PrevEntryRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  PrevEntryInput          `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *PrevEntryRequest) Reset()         { *m = PrevEntryRequest{} }
func (m *PrevEntryRequest) String() string { return proto.CompactTextString(m) }
func (*PrevEntryRequest) ProtoMessage()    {}
func (*PrevEntryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{24}
}
func (m *PrevEntryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrevEntryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrevEntryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrevEntryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrevEntryRequest.Merge(m, src)
}
func (m *PrevEntryRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrevEntryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrevEntryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrevEntryRequest proto.InternalMessageInfo

func (m *PrevEntryRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *PrevEntryRequest) GetInput() PrevEntryInput {
	if m != nil {
		return m.Input
	}
	return PrevEntryInput{}
}

type PrevEntryInput struct {
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *PrevEntryInput) Reset()         { *m = PrevEntryInput{} }
func (m *PrevEntryInput) String() string { return proto.CompactTextString(m) }
func (*PrevEntryInput) ProtoMessage()    {}
func (*PrevEntryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{25}
}
func (m *PrevEntryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrevEntryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrevEntryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrevEntryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrevEntryInput.Merge(m, src)
}
func (m *PrevEntryInput) XXX_Size() int {
	return m.Size()
}
func (m *PrevEntryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PrevEntryInput.DiscardUnknown(m)
}

var xxx_messageInfo_PrevEntryInput proto.InternalMessageInfo

func (m *PrevEntryInput) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type PrevEntryResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output PrevEntryOutput          `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *PrevEntryResponse) Reset()         { *m = PrevEntryResponse{} }
func (m *PrevEntryResponse) String() string { return proto.CompactTextString(m) }
func (*PrevEntryResponse) ProtoMessage()    {}
func (*PrevEntryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{26}
}
func (m *PrevEntryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrevEntryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrevEntryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrevEntryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrevEntryResponse.Merge(m, src)
}
func (m *PrevEntryResponse) XXX_Size() int {
	return m.Size()
}
func (m *PrevEntryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PrevEntryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PrevEntryResponse proto.InternalMessageInfo

func (m *PrevEntryResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *PrevEntryResponse) GetOutput() PrevEntryOutput {
	if m != nil {
		return m.Output
	}
	return PrevEntryOutput{}
}

type PrevEntryOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *PrevEntryOutput) Reset()         { *m = PrevEntryOutput{} }
func (m *PrevEntryOutput) String() string { return proto.CompactTextString(m) }
func (*PrevEntryOutput) ProtoMessage()    {}
func (*PrevEntryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{27}
}
func (m *PrevEntryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrevEntryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrevEntryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrevEntryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrevEntryOutput.Merge(m, src)
}
func (m *PrevEntryOutput) XXX_Size() int {
	return m.Size()
}
func (m *PrevEntryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_PrevEntryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_PrevEntryOutput proto.InternalMessageInfo

func (m *PrevEntryOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type NextEntryRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  NextEntryInput          `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *NextEntryRequest) Reset()         { *m = NextEntryRequest{} }
func (m *NextEntryRequest) String() string { return proto.CompactTextString(m) }
func (*NextEntryRequest) ProtoMessage()    {}
func (*NextEntryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{28}
}
func (m *NextEntryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextEntryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextEntryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextEntryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextEntryRequest.Merge(m, src)
}
func (m *NextEntryRequest) XXX_Size() int {
	return m.Size()
}
func (m *NextEntryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NextEntryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NextEntryRequest proto.InternalMessageInfo

func (m *NextEntryRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *NextEntryRequest) GetInput() NextEntryInput {
	if m != nil {
		return m.Input
	}
	return NextEntryInput{}
}

type NextEntryInput struct {
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *NextEntryInput) Reset()         { *m = NextEntryInput{} }
func (m *NextEntryInput) String() string { return proto.CompactTextString(m) }
func (*NextEntryInput) ProtoMessage()    {}
func (*NextEntryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{29}
}
func (m *NextEntryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextEntryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextEntryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextEntryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextEntryInput.Merge(m, src)
}
func (m *NextEntryInput) XXX_Size() int {
	return m.Size()
}
func (m *NextEntryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_NextEntryInput.DiscardUnknown(m)
}

var xxx_messageInfo_NextEntryInput proto.InternalMessageInfo

func (m *NextEntryInput) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type NextEntryResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output NextEntryOutput          `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *NextEntryResponse) Reset()         { *m = NextEntryResponse{} }
func (m *NextEntryResponse) String() string { return proto.CompactTextString(m) }
func (*NextEntryResponse) ProtoMessage()    {}
func (*NextEntryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{30}
}
func (m *NextEntryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextEntryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextEntryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextEntryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextEntryResponse.Merge(m, src)
}
func (m *NextEntryResponse) XXX_Size() int {
	return m.Size()
}
func (m *NextEntryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NextEntryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NextEntryResponse proto.InternalMessageInfo

func (m *NextEntryResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *NextEntryResponse) GetOutput() NextEntryOutput {
	if m != nil {
		return m.Output
	}
	return NextEntryOutput{}
}

type NextEntryOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *NextEntryOutput) Reset()         { *m = NextEntryOutput{} }
func (m *NextEntryOutput) String() string { return proto.CompactTextString(m) }
func (*NextEntryOutput) ProtoMessage()    {}
func (*NextEntryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{31}
}
func (m *NextEntryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextEntryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextEntryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextEntryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextEntryOutput.Merge(m, src)
}
func (m *NextEntryOutput) XXX_Size() int {
	return m.Size()
}
func (m *NextEntryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_NextEntryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_NextEntryOutput proto.InternalMessageInfo

func (m *NextEntryOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type RemoveRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  RemoveInput             `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *RemoveRequest) Reset()         { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()    {}
func (*RemoveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{32}
}
func (m *RemoveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveRequest.Merge(m, src)
}
func (m *RemoveRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveRequest proto.InternalMessageInfo

func (m *RemoveRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *RemoveRequest) GetInput() RemoveInput {
	if m != nil {
		return m.Input
	}
	return RemoveInput{}
}

type RemoveInput struct {
	Index     uint64          `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Key       string          `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Timestamp *meta.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *RemoveInput) Reset()         { *m = RemoveInput{} }
func (m *RemoveInput) String() string { return proto.CompactTextString(m) }
func (*RemoveInput) ProtoMessage()    {}
func (*RemoveInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{33}
}
func (m *RemoveInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveInput.Merge(m, src)
}
func (m *RemoveInput) XXX_Size() int {
	return m.Size()
}
func (m *RemoveInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveInput.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveInput proto.InternalMessageInfo

func (m *RemoveInput) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *RemoveInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RemoveInput) GetTimestamp() *meta.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type RemoveResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output RemoveOutput             `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *RemoveResponse) Reset()         { *m = RemoveResponse{} }
func (m *RemoveResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveResponse) ProtoMessage()    {}
func (*RemoveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{34}
}
func (m *RemoveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveResponse.Merge(m, src)
}
func (m *RemoveResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveResponse proto.InternalMessageInfo

func (m *RemoveResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *RemoveResponse) GetOutput() RemoveOutput {
	if m != nil {
		return m.Output
	}
	return RemoveOutput{}
}

type RemoveOutput struct {
	Entry *Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
}

func (m *RemoveOutput) Reset()         { *m = RemoveOutput{} }
func (m *RemoveOutput) String() string { return proto.CompactTextString(m) }
func (*RemoveOutput) ProtoMessage()    {}
func (*RemoveOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{35}
}
func (m *RemoveOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveOutput.Merge(m, src)
}
func (m *RemoveOutput) XXX_Size() int {
	return m.Size()
}
func (m *RemoveOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveOutput.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveOutput proto.InternalMessageInfo

func (m *RemoveOutput) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type ClearRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  ClearInput              `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *ClearRequest) Reset()         { *m = ClearRequest{} }
func (m *ClearRequest) String() string { return proto.CompactTextString(m) }
func (*ClearRequest) ProtoMessage()    {}
func (*ClearRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{36}
}
func (m *ClearRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRequest.Merge(m, src)
}
func (m *ClearRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRequest proto.InternalMessageInfo

func (m *ClearRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *ClearRequest) GetInput() ClearInput {
	if m != nil {
		return m.Input
	}
	return ClearInput{}
}

type ClearInput struct {
}

func (m *ClearInput) Reset()         { *m = ClearInput{} }
func (m *ClearInput) String() string { return proto.CompactTextString(m) }
func (*ClearInput) ProtoMessage()    {}
func (*ClearInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{37}
}
func (m *ClearInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearInput.Merge(m, src)
}
func (m *ClearInput) XXX_Size() int {
	return m.Size()
}
func (m *ClearInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearInput.DiscardUnknown(m)
}

var xxx_messageInfo_ClearInput proto.InternalMessageInfo

type ClearResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output ClearOutput              `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *ClearResponse) Reset()         { *m = ClearResponse{} }
func (m *ClearResponse) String() string { return proto.CompactTextString(m) }
func (*ClearResponse) ProtoMessage()    {}
func (*ClearResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{38}
}
func (m *ClearResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearResponse.Merge(m, src)
}
func (m *ClearResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClearResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClearResponse proto.InternalMessageInfo

func (m *ClearResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *ClearResponse) GetOutput() ClearOutput {
	if m != nil {
		return m.Output
	}
	return ClearOutput{}
}

type ClearOutput struct {
}

func (m *ClearOutput) Reset()         { *m = ClearOutput{} }
func (m *ClearOutput) String() string { return proto.CompactTextString(m) }
func (*ClearOutput) ProtoMessage()    {}
func (*ClearOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{39}
}
func (m *ClearOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearOutput.Merge(m, src)
}
func (m *ClearOutput) XXX_Size() int {
	return m.Size()
}
func (m *ClearOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ClearOutput proto.InternalMessageInfo

type EntriesRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  EntriesInput            `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *EntriesRequest) Reset()         { *m = EntriesRequest{} }
func (m *EntriesRequest) String() string { return proto.CompactTextString(m) }
func (*EntriesRequest) ProtoMessage()    {}
func (*EntriesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{40}
}
func (m *EntriesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesRequest.Merge(m, src)
}
func (m *EntriesRequest) XXX_Size() int {
	return m.Size()
}
func (m *EntriesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesRequest proto.InternalMessageInfo

func (m *EntriesRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *EntriesRequest) GetInput() EntriesInput {
	if m != nil {
		return m.Input
	}
	return EntriesInput{}
}

type EntriesInput struct {
}

func (m *EntriesInput) Reset()         { *m = EntriesInput{} }
func (m *EntriesInput) String() string { return proto.CompactTextString(m) }
func (*EntriesInput) ProtoMessage()    {}
func (*EntriesInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{41}
}
func (m *EntriesInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesInput.Merge(m, src)
}
func (m *EntriesInput) XXX_Size() int {
	return m.Size()
}
func (m *EntriesInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesInput.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesInput proto.InternalMessageInfo

type EntriesResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output EntriesOutput            `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *EntriesResponse) Reset()         { *m = EntriesResponse{} }
func (m *EntriesResponse) String() string { return proto.CompactTextString(m) }
func (*EntriesResponse) ProtoMessage()    {}
func (*EntriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{42}
}
func (m *EntriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesResponse.Merge(m, src)
}
func (m *EntriesResponse) XXX_Size() int {
	return m.Size()
}
func (m *EntriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesResponse proto.InternalMessageInfo

func (m *EntriesResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *EntriesResponse) GetOutput() EntriesOutput {
	if m != nil {
		return m.Output
	}
	return EntriesOutput{}
}

type EntriesOutput struct {
	Entry Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry"`
}

func (m *EntriesOutput) Reset()         { *m = EntriesOutput{} }
func (m *EntriesOutput) String() string { return proto.CompactTextString(m) }
func (*EntriesOutput) ProtoMessage()    {}
func (*EntriesOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{43}
}
func (m *EntriesOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesOutput.Merge(m, src)
}
func (m *EntriesOutput) XXX_Size() int {
	return m.Size()
}
func (m *EntriesOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesOutput proto.InternalMessageInfo

func (m *EntriesOutput) GetEntry() Entry {
	if m != nil {
		return m.Entry
	}
	return Entry{}
}

type EventsRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  EventsInput             `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *EventsRequest) Reset()         { *m = EventsRequest{} }
func (m *EventsRequest) String() string { return proto.CompactTextString(m) }
func (*EventsRequest) ProtoMessage()    {}
func (*EventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{44}
}
func (m *EventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsRequest.Merge(m, src)
}
func (m *EventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventsRequest proto.InternalMessageInfo

func (m *EventsRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *EventsRequest) GetInput() EventsInput {
	if m != nil {
		return m.Input
	}
	return EventsInput{}
}

type EventsInput struct {
	Pos    Position `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos"`
	Replay bool     `protobuf:"varint,2,opt,name=replay,proto3" json:"replay,omitempty"`
}

func (m *EventsInput) Reset()         { *m = EventsInput{} }
func (m *EventsInput) String() string { return proto.CompactTextString(m) }
func (*EventsInput) ProtoMessage()    {}
func (*EventsInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{45}
}
func (m *EventsInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsInput.Merge(m, src)
}
func (m *EventsInput) XXX_Size() int {
	return m.Size()
}
func (m *EventsInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsInput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsInput proto.InternalMessageInfo

func (m *EventsInput) GetPos() Position {
	if m != nil {
		return m.Pos
	}
	return Position{}
}

func (m *EventsInput) GetReplay() bool {
	if m != nil {
		return m.Replay
	}
	return false
}

type EventsResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output EventsOutput             `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *EventsResponse) Reset()         { *m = EventsResponse{} }
func (m *EventsResponse) String() string { return proto.CompactTextString(m) }
func (*EventsResponse) ProtoMessage()    {}
func (*EventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{46}
}
func (m *EventsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsResponse.Merge(m, src)
}
func (m *EventsResponse) XXX_Size() int {
	return m.Size()
}
func (m *EventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EventsResponse proto.InternalMessageInfo

func (m *EventsResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *EventsResponse) GetOutput() EventsOutput {
	if m != nil {
		return m.Output
	}
	return EventsOutput{}
}

type EventsOutput struct {
	Type  EventsOutput_Type `protobuf:"varint,1,opt,name=type,proto3,enum=atomix.primitive.indexedmap.EventsOutput_Type" json:"type,omitempty"`
	Entry Entry             `protobuf:"bytes,2,opt,name=entry,proto3" json:"entry"`
}

func (m *EventsOutput) Reset()         { *m = EventsOutput{} }
func (m *EventsOutput) String() string { return proto.CompactTextString(m) }
func (*EventsOutput) ProtoMessage()    {}
func (*EventsOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{47}
}
func (m *EventsOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsOutput.Merge(m, src)
}
func (m *EventsOutput) XXX_Size() int {
	return m.Size()
}
func (m *EventsOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsOutput proto.InternalMessageInfo

func (m *EventsOutput) GetType() EventsOutput_Type {
	if m != nil {
		return m.Type
	}
	return EventsOutput_NONE
}

func (m *EventsOutput) GetEntry() Entry {
	if m != nil {
		return m.Entry
	}
	return Entry{}
}

type Position struct {
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Key   string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{48}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Position) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type Entry struct {
	Pos   Position `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos"`
	Value Value    `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{49}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetPos() Position {
	if m != nil {
		return m.Pos
	}
	return Position{}
}

func (m *Entry) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

type Value struct {
	Value     []byte         `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Timestamp meta.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	TTL       *time.Duration `protobuf:"bytes,3,opt,name=ttl,proto3,stdduration" json:"ttl,omitempty"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{50}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

func (m *Value) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetTimestamp() meta.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return meta.Timestamp{}
}

func (m *Value) GetTTL() *time.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type IndexedMapRequest struct {
	Header primitive.RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Input  IndexedMapInput         `protobuf:"bytes,2,opt,name=input,proto3" json:"input"`
}

func (m *IndexedMapRequest) Reset()         { *m = IndexedMapRequest{} }
func (m *IndexedMapRequest) String() string { return proto.CompactTextString(m) }
func (*IndexedMapRequest) ProtoMessage()    {}
func (*IndexedMapRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{51}
}
func (m *IndexedMapRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexedMapRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexedMapRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexedMapRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexedMapRequest.Merge(m, src)
}
func (m *IndexedMapRequest) XXX_Size() int {
	return m.Size()
}
func (m *IndexedMapRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexedMapRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IndexedMapRequest proto.InternalMessageInfo

func (m *IndexedMapRequest) GetHeader() primitive.RequestHeader {
	if m != nil {
		return m.Header
	}
	return primitive.RequestHeader{}
}

func (m *IndexedMapRequest) GetInput() IndexedMapInput {
	if m != nil {
		return m.Input
	}
	return IndexedMapInput{}
}

type IndexedMapInput struct {
	// Types that are valid to be assigned to Input:
	//	*IndexedMapInput_Size_
	//	*IndexedMapInput_Exists
	//	*IndexedMapInput_Put
	//	*IndexedMapInput_Get
	//	*IndexedMapInput_FirstEntry
	//	*IndexedMapInput_LastEntry
	//	*IndexedMapInput_PrevEntry
	//	*IndexedMapInput_NextEntry
	//	*IndexedMapInput_Remove
	//	*IndexedMapInput_Clear
	//	*IndexedMapInput_Events
	//	*IndexedMapInput_Entries
	Input isIndexedMapInput_Input `protobuf_oneof:"input"`
}

func (m *IndexedMapInput) Reset()         { *m = IndexedMapInput{} }
func (m *IndexedMapInput) String() string { return proto.CompactTextString(m) }
func (*IndexedMapInput) ProtoMessage()    {}
func (*IndexedMapInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{52}
}
func (m *IndexedMapInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexedMapInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexedMapInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexedMapInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexedMapInput.Merge(m, src)
}
func (m *IndexedMapInput) XXX_Size() int {
	return m.Size()
}
func (m *IndexedMapInput) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexedMapInput.DiscardUnknown(m)
}

var xxx_messageInfo_IndexedMapInput proto.InternalMessageInfo

type isIndexedMapInput_Input interface {
	isIndexedMapInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IndexedMapInput_Size_ struct {
	Size_ *SizeInput `protobuf:"bytes,1,opt,name=size,proto3,oneof" json:"size,omitempty"`
}
type IndexedMapInput_Exists struct {
	Exists *ExistsInput `protobuf:"bytes,2,opt,name=exists,proto3,oneof" json:"exists,omitempty"`
}
type IndexedMapInput_Put struct {
	Put *PutInput `protobuf:"bytes,3,opt,name=put,proto3,oneof" json:"put,omitempty"`
}
type IndexedMapInput_Get struct {
	Get *GetInput `protobuf:"bytes,4,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type IndexedMapInput_FirstEntry struct {
	FirstEntry *FirstEntryInput `protobuf:"bytes,5,opt,name=first_entry,json=firstEntry,proto3,oneof" json:"first_entry,omitempty"`
}
type IndexedMapInput_LastEntry struct {
	LastEntry *LastEntryInput `protobuf:"bytes,6,opt,name=last_entry,json=lastEntry,proto3,oneof" json:"last_entry,omitempty"`
}
type IndexedMapInput_PrevEntry struct {
	PrevEntry *PrevEntryInput `protobuf:"bytes,7,opt,name=prev_entry,json=prevEntry,proto3,oneof" json:"prev_entry,omitempty"`
}
type IndexedMapInput_NextEntry struct {
	NextEntry *NextEntryInput `protobuf:"bytes,8,opt,name=next_entry,json=nextEntry,proto3,oneof" json:"next_entry,omitempty"`
}
type IndexedMapInput_Remove struct {
	Remove *RemoveInput `protobuf:"bytes,9,opt,name=remove,proto3,oneof" json:"remove,omitempty"`
}
type IndexedMapInput_Clear struct {
	Clear *ClearInput `protobuf:"bytes,10,opt,name=clear,proto3,oneof" json:"clear,omitempty"`
}
type IndexedMapInput_Events struct {
	Events *EventsInput `protobuf:"bytes,11,opt,name=events,proto3,oneof" json:"events,omitempty"`
}
type IndexedMapInput_Entries struct {
	Entries *EntriesInput `protobuf:"bytes,12,opt,name=entries,proto3,oneof" json:"entries,omitempty"`
}

func (*IndexedMapInput_Size_) isIndexedMapInput_Input()      {}
func (*IndexedMapInput_Exists) isIndexedMapInput_Input()     {}
func (*IndexedMapInput_Put) isIndexedMapInput_Input()        {}
func (*IndexedMapInput_Get) isIndexedMapInput_Input()        {}
func (*IndexedMapInput_FirstEntry) isIndexedMapInput_Input() {}
func (*IndexedMapInput_LastEntry) isIndexedMapInput_Input()  {}
func (*IndexedMapInput_PrevEntry) isIndexedMapInput_Input()  {}
func (*IndexedMapInput_NextEntry) isIndexedMapInput_Input()  {}
func (*IndexedMapInput_Remove) isIndexedMapInput_Input()     {}
func (*IndexedMapInput_Clear) isIndexedMapInput_Input()      {}
func (*IndexedMapInput_Events) isIndexedMapInput_Input()     {}
func (*IndexedMapInput_Entries) isIndexedMapInput_Input()    {}

func (m *IndexedMapInput) GetInput() isIndexedMapInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *IndexedMapInput) GetSize_() *SizeInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Size_); ok {
		return x.Size_
	}
	return nil
}

func (m *IndexedMapInput) GetExists() *ExistsInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Exists); ok {
		return x.Exists
	}
	return nil
}

func (m *IndexedMapInput) GetPut() *PutInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Put); ok {
		return x.Put
	}
	return nil
}

func (m *IndexedMapInput) GetGet() *GetInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *IndexedMapInput) GetFirstEntry() *FirstEntryInput {
	if x, ok := m.GetInput().(*IndexedMapInput_FirstEntry); ok {
		return x.FirstEntry
	}
	return nil
}

func (m *IndexedMapInput) GetLastEntry() *LastEntryInput {
	if x, ok := m.GetInput().(*IndexedMapInput_LastEntry); ok {
		return x.LastEntry
	}
	return nil
}

func (m *IndexedMapInput) GetPrevEntry() *PrevEntryInput {
	if x, ok := m.GetInput().(*IndexedMapInput_PrevEntry); ok {
		return x.PrevEntry
	}
	return nil
}

func (m *IndexedMapInput) GetNextEntry() *NextEntryInput {
	if x, ok := m.GetInput().(*IndexedMapInput_NextEntry); ok {
		return x.NextEntry
	}
	return nil
}

func (m *IndexedMapInput) GetRemove() *RemoveInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Remove); ok {
		return x.Remove
	}
	return nil
}

func (m *IndexedMapInput) GetClear() *ClearInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Clear); ok {
		return x.Clear
	}
	return nil
}

func (m *IndexedMapInput) GetEvents() *EventsInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Events); ok {
		return x.Events
	}
	return nil
}

func (m *IndexedMapInput) GetEntries() *EntriesInput {
	if x, ok := m.GetInput().(*IndexedMapInput_Entries); ok {
		return x.Entries
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IndexedMapInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IndexedMapInput_Size_)(nil),
		(*IndexedMapInput_Exists)(nil),
		(*IndexedMapInput_Put)(nil),
		(*IndexedMapInput_Get)(nil),
		(*IndexedMapInput_FirstEntry)(nil),
		(*IndexedMapInput_LastEntry)(nil),
		(*IndexedMapInput_PrevEntry)(nil),
		(*IndexedMapInput_NextEntry)(nil),
		(*IndexedMapInput_Remove)(nil),
		(*IndexedMapInput_Clear)(nil),
		(*IndexedMapInput_Events)(nil),
		(*IndexedMapInput_Entries)(nil),
	}
}

type IndexedMapResponse struct {
	Header primitive.ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Output IndexedMapOutput         `protobuf:"bytes,2,opt,name=output,proto3" json:"output"`
}

func (m *IndexedMapResponse) Reset()         { *m = IndexedMapResponse{} }
func (m *IndexedMapResponse) String() string { return proto.CompactTextString(m) }
func (*IndexedMapResponse) ProtoMessage()    {}
func (*IndexedMapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{53}
}
func (m *IndexedMapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexedMapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexedMapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexedMapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexedMapResponse.Merge(m, src)
}
func (m *IndexedMapResponse) XXX_Size() int {
	return m.Size()
}
func (m *IndexedMapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexedMapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IndexedMapResponse proto.InternalMessageInfo

func (m *IndexedMapResponse) GetHeader() primitive.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return primitive.ResponseHeader{}
}

func (m *IndexedMapResponse) GetOutput() IndexedMapOutput {
	if m != nil {
		return m.Output
	}
	return IndexedMapOutput{}
}

type IndexedMapOutput struct {
	// Types that are valid to be assigned to Output:
	//	*IndexedMapOutput_Size_
	//	*IndexedMapOutput_Exists
	//	*IndexedMapOutput_Put
	//	*IndexedMapOutput_Get
	//	*IndexedMapOutput_FirstEntry
	//	*IndexedMapOutput_LastEntry
	//	*IndexedMapOutput_PrevEntry
	//	*IndexedMapOutput_NextEntry
	//	*IndexedMapOutput_Remove
	//	*IndexedMapOutput_Clear
	//	*IndexedMapOutput_Events
	//	*IndexedMapOutput_Entries
	Output isIndexedMapOutput_Output `protobuf_oneof:"output"`
}

func (m *IndexedMapOutput) Reset()         { *m = IndexedMapOutput{} }
func (m *IndexedMapOutput) String() string { return proto.CompactTextString(m) }
func (*IndexedMapOutput) ProtoMessage()    {}
func (*IndexedMapOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eeb219002b11ae5, []int{54}
}
func (m *IndexedMapOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexedMapOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexedMapOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexedMapOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexedMapOutput.Merge(m, src)
}
func (m *IndexedMapOutput) XXX_Size() int {
	return m.Size()
}
func (m *IndexedMapOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexedMapOutput.DiscardUnknown(m)
}

var xxx_messageInfo_IndexedMapOutput proto.InternalMessageInfo

type isIndexedMapOutput_Output interface {
	isIndexedMapOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IndexedMapOutput_Size_ struct {
	Size_ *SizeOutput `protobuf:"bytes,1,opt,name=size,proto3,oneof" json:"size,omitempty"`
}
type IndexedMapOutput_Exists struct {
	Exists *ExistsOutput `protobuf:"bytes,2,opt,name=exists,proto3,oneof" json:"exists,omitempty"`
}
type IndexedMapOutput_Put struct {
	Put *PutOutput `protobuf:"bytes,3,opt,name=put,proto3,oneof" json:"put,omitempty"`
}
type IndexedMapOutput_Get struct {
	Get *GetOutput `protobuf:"bytes,4,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type IndexedMapOutput_FirstEntry struct {
	FirstEntry *FirstEntryOutput `protobuf:"bytes,5,opt,name=first_entry,json=firstEntry,proto3,oneof" json:"first_entry,omitempty"`
}
type IndexedMapOutput_LastEntry struct {
	LastEntry *LastEntryOutput `protobuf:"bytes,6,opt,name=last_entry,json=lastEntry,proto3,oneof" json:"last_entry,omitempty"`
}
type IndexedMapOutput_PrevEntry struct {
	PrevEntry *PrevEntryOutput `protobuf:"bytes,7,opt,name=prev_entry,json=prevEntry,proto3,oneof" json:"prev_entry,omitempty"`
}
type IndexedMapOutput_NextEntry struct {
	NextEntry *NextEntryOutput `protobuf:"bytes,8,opt,name=next_entry,json=nextEntry,proto3,oneof" json:"next_entry,omitempty"`
}
type IndexedMapOutput_Remove struct {
	Remove *RemoveOutput `protobuf:"bytes,9,opt,name=remove,proto3,oneof" json:"remove,omitempty"`
}
type IndexedMapOutput_Clear struct {
	Clear *ClearOutput `protobuf:"bytes,10,opt,name=clear,proto3,oneof" json:"clear,omitempty"`
}
type IndexedMapOutput_Events struct {
	Events *EventsOutput `protobuf:"bytes,11,opt,name=events,proto3,oneof" json:"events,omitempty"`
}
type IndexedMapOutput_Entries struct {
	Entries *EntriesOutput `protobuf:"bytes,12,opt,name=entries,proto3,oneof" json:"entries,omitempty"`
}

func (*IndexedMapOutput_Size_) isIndexedMapOutput_Output()      {}
func (*IndexedMapOutput_Exists) isIndexedMapOutput_Output()     {}
func (*IndexedMapOutput_Put) isIndexedMapOutput_Output()        {}
func (*IndexedMapOutput_Get) isIndexedMapOutput_Output()        {}
func (*IndexedMapOutput_FirstEntry) isIndexedMapOutput_Output() {}
func (*IndexedMapOutput_LastEntry) isIndexedMapOutput_Output()  {}
func (*IndexedMapOutput_PrevEntry) isIndexedMapOutput_Output()  {}
func (*IndexedMapOutput_NextEntry) isIndexedMapOutput_Output()  {}
func (*IndexedMapOutput_Remove) isIndexedMapOutput_Output()     {}
func (*IndexedMapOutput_Clear) isIndexedMapOutput_Output()      {}
func (*IndexedMapOutput_Events) isIndexedMapOutput_Output()     {}
func (*IndexedMapOutput_Entries) isIndexedMapOutput_Output()    {}

func (m *IndexedMapOutput) GetOutput() isIndexedMapOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *IndexedMapOutput) GetSize_() *SizeOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Size_); ok {
		return x.Size_
	}
	return nil
}

func (m *IndexedMapOutput) GetExists() *ExistsOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Exists); ok {
		return x.Exists
	}
	return nil
}

func (m *IndexedMapOutput) GetPut() *PutOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Put); ok {
		return x.Put
	}
	return nil
}

func (m *IndexedMapOutput) GetGet() *GetOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *IndexedMapOutput) GetFirstEntry() *FirstEntryOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_FirstEntry); ok {
		return x.FirstEntry
	}
	return nil
}

func (m *IndexedMapOutput) GetLastEntry() *LastEntryOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_LastEntry); ok {
		return x.LastEntry
	}
	return nil
}

func (m *IndexedMapOutput) GetPrevEntry() *PrevEntryOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_PrevEntry); ok {
		return x.PrevEntry
	}
	return nil
}

func (m *IndexedMapOutput) GetNextEntry() *NextEntryOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_NextEntry); ok {
		return x.NextEntry
	}
	return nil
}

func (m *IndexedMapOutput) GetRemove() *RemoveOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Remove); ok {
		return x.Remove
	}
	return nil
}

func (m *IndexedMapOutput) GetClear() *ClearOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Clear); ok {
		return x.Clear
	}
	return nil
}

func (m *IndexedMapOutput) GetEvents() *EventsOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Events); ok {
		return x.Events
	}
	return nil
}

func (m *IndexedMapOutput) GetEntries() *EntriesOutput {
	if x, ok := m.GetOutput().(*IndexedMapOutput_Entries); ok {
		return x.Entries
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IndexedMapOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IndexedMapOutput_Size_)(nil),
		(*IndexedMapOutput_Exists)(nil),
		(*IndexedMapOutput_Put)(nil),
		(*IndexedMapOutput_Get)(nil),
		(*IndexedMapOutput_FirstEntry)(nil),
		(*IndexedMapOutput_LastEntry)(nil),
		(*IndexedMapOutput_PrevEntry)(nil),
		(*IndexedMapOutput_NextEntry)(nil),
		(*IndexedMapOutput_Remove)(nil),
		(*IndexedMapOutput_Clear)(nil),
		(*IndexedMapOutput_Events)(nil),
		(*IndexedMapOutput_Entries)(nil),
	}
}

func init() {
	proto.RegisterEnum("atomix.primitive.indexedmap.EventsOutput_Type", EventsOutput_Type_name, EventsOutput_Type_value)
	proto.RegisterType((*ExistsRequest)(nil), "atomix.primitive.indexedmap.ExistsRequest")
	proto.RegisterType((*ExistsInput)(nil), "atomix.primitive.indexedmap.ExistsInput")
	proto.RegisterType((*ExistsResponse)(nil), "atomix.primitive.indexedmap.ExistsResponse")
	proto.RegisterType((*ExistsOutput)(nil), "atomix.primitive.indexedmap.ExistsOutput")
	proto.RegisterType((*SizeRequest)(nil), "atomix.primitive.indexedmap.SizeRequest")
	proto.RegisterType((*SizeInput)(nil), "atomix.primitive.indexedmap.SizeInput")
	proto.RegisterType((*SizeResponse)(nil), "atomix.primitive.indexedmap.SizeResponse")
	proto.RegisterType((*SizeOutput)(nil), "atomix.primitive.indexedmap.SizeOutput")
	proto.RegisterType((*PutRequest)(nil), "atomix.primitive.indexedmap.PutRequest")
	proto.RegisterType((*PutInput)(nil), "atomix.primitive.indexedmap.PutInput")
	proto.RegisterType((*PutResponse)(nil), "atomix.primitive.indexedmap.PutResponse")
	proto.RegisterType((*PutOutput)(nil), "atomix.primitive.indexedmap.PutOutput")
	proto.RegisterType((*GetRequest)(nil), "atomix.primitive.indexedmap.GetRequest")
	proto.RegisterType((*GetInput)(nil), "atomix.primitive.indexedmap.GetInput")
	proto.RegisterType((*GetResponse)(nil), "atomix.primitive.indexedmap.GetResponse")
	proto.RegisterType((*GetOutput)(nil), "atomix.primitive.indexedmap.GetOutput")
	proto.RegisterType((*FirstEntryRequest)(nil), "atomix.primitive.indexedmap.FirstEntryRequest")
	proto.RegisterType((*FirstEntryInput)(nil), "atomix.primitive.indexedmap.FirstEntryInput")
	proto.RegisterType((*FirstEntryResponse)(nil), "atomix.primitive.indexedmap.FirstEntryResponse")
	proto.RegisterType((*FirstEntryOutput)(nil), "atomix.primitive.indexedmap.FirstEntryOutput")
	proto.RegisterType((*LastEntryRequest)(nil), "atomix.primitive.indexedmap.LastEntryRequest")
	proto.RegisterType((*LastEntryInput)(nil), "atomix.primitive.indexedmap.LastEntryInput")
	proto.RegisterType((*LastEntryResponse)(nil), "atomix.primitive.indexedmap.LastEntryResponse")
	proto.RegisterType((*LastEntryOutput)(nil), "atomix.primitive.indexedmap.LastEntryOutput")
	proto.RegisterType((*PrevEntryRequest)(nil), "atomix.primitive.indexedmap.PrevEntryRequest")
	proto.RegisterType((*PrevEntryInput)(nil), "atomix.primitive.indexedmap.PrevEntryInput")
	proto.RegisterType((*PrevEntryResponse)(nil), "atomix.primitive.indexedmap.PrevEntryResponse")
	proto.RegisterType((*PrevEntryOutput)(nil), "atomix.primitive.indexedmap.PrevEntryOutput")
	proto.RegisterType((*NextEntryRequest)(nil), "atomix.primitive.indexedmap.NextEntryRequest")
	proto.RegisterType((*NextEntryInput)(nil), "atomix.primitive.indexedmap.NextEntryInput")
	proto.RegisterType((*NextEntryResponse)(nil), "atomix.primitive.indexedmap.NextEntryResponse")
	proto.RegisterType((*NextEntryOutput)(nil), "atomix.primitive.indexedmap.NextEntryOutput")
	proto.RegisterType((*RemoveRequest)(nil), "atomix.primitive.indexedmap.RemoveRequest")
	proto.RegisterType((*RemoveInput)(nil), "atomix.primitive.indexedmap.RemoveInput")
	proto.RegisterType((*RemoveResponse)(nil), "atomix.primitive.indexedmap.RemoveResponse")
	proto.RegisterType((*RemoveOutput)(nil), "atomix.primitive.indexedmap.RemoveOutput")
	proto.RegisterType((*ClearRequest)(nil), "atomix.primitive.indexedmap.ClearRequest")
	proto.RegisterType((*ClearInput)(nil), "atomix.primitive.indexedmap.ClearInput")
	proto.RegisterType((*ClearResponse)(nil), "atomix.primitive.indexedmap.ClearResponse")
	proto.RegisterType((*ClearOutput)(nil), "atomix.primitive.indexedmap.ClearOutput")
	proto.RegisterType((*EntriesRequest)(nil), "atomix.primitive.indexedmap.EntriesRequest")
	proto.RegisterType((*EntriesInput)(nil), "atomix.primitive.indexedmap.EntriesInput")
	proto.RegisterType((*EntriesResponse)(nil), "atomix.primitive.indexedmap.EntriesResponse")
	proto.RegisterType((*EntriesOutput)(nil), "atomix.primitive.indexedmap.EntriesOutput")
	proto.RegisterType((*EventsRequest)(nil), "atomix.primitive.indexedmap.EventsRequest")
	proto.RegisterType((*EventsInput)(nil), "atomix.primitive.indexedmap.EventsInput")
	proto.RegisterType((*EventsResponse)(nil), "atomix.primitive.indexedmap.EventsResponse")
	proto.RegisterType((*EventsOutput)(nil), "atomix.primitive.indexedmap.EventsOutput")
	proto.RegisterType((*Position)(nil), "atomix.primitive.indexedmap.Position")
	proto.RegisterType((*Entry)(nil), "atomix.primitive.indexedmap.Entry")
	proto.RegisterType((*Value)(nil), "atomix.primitive.indexedmap.Value")
	proto.RegisterType((*IndexedMapRequest)(nil), "atomix.primitive.indexedmap.IndexedMapRequest")
	proto.RegisterType((*IndexedMapInput)(nil), "atomix.primitive.indexedmap.IndexedMapInput")
	proto.RegisterType((*IndexedMapResponse)(nil), "atomix.primitive.indexedmap.IndexedMapResponse")
	proto.RegisterType((*IndexedMapOutput)(nil), "atomix.primitive.indexedmap.IndexedMapOutput")
}

func init() {
	proto.RegisterFile("atomix/primitive/indexedmap/indexedmap.proto", fileDescriptor_7eeb219002b11ae5)
}

var fileDescriptor_7eeb219002b11ae5 = []byte{
	// 1698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xf6, 0xc4, 0x1f, 0x71, 0x5e, 0x3b, 0x89, 0x3b, 0xaa, 0x90, 0x1b, 0xa4, 0x24, 0x5d, 0xa9,
	0x6d, 0xd2, 0xa6, 0x9b, 0x12, 0x2e, 0xa5, 0xa2, 0x85, 0x3a, 0x71, 0xe3, 0x90, 0x4f, 0x6d, 0x43,
	0x8f, 0x54, 0xdb, 0x78, 0x12, 0x56, 0xd8, 0xde, 0x65, 0x77, 0x1d, 0x25, 0x3d, 0x21, 0x0e, 0x88,
	0x63, 0x4f, 0xa8, 0x02, 0x0a, 0xa2, 0x20, 0x21, 0xae, 0x48, 0xfc, 0x87, 0x1e, 0x38, 0xf4, 0xc8,
	0x85, 0x82, 0xd2, 0x23, 0x47, 0xfe, 0x00, 0x9a, 0x99, 0xfd, 0x98, 0xdd, 0x64, 0xbd, 0xbb, 0xd8,
	0x92, 0x6f, 0xde, 0x9d, 0x67, 0xde, 0x8f, 0x79, 0x66, 0x9e, 0x9d, 0xf7, 0x35, 0x2c, 0xa8, 0xb6,
	0xde, 0xd6, 0x8e, 0x16, 0x0d, 0x53, 0x6b, 0x6b, 0xb6, 0x76, 0x48, 0x16, 0xb5, 0x4e, 0x93, 0x1c,
	0x91, 0x66, 0x5b, 0x35, 0x84, 0x9f, 0xb2, 0x61, 0xea, 0xb6, 0x8e, 0xdf, 0xe4, 0x68, 0xd9, 0x43,
	0xcb, 0x3e, 0x64, 0x6a, 0xfa, 0x40, 0xd7, 0x0f, 0x5a, 0x64, 0x91, 0x41, 0x1f, 0x75, 0xf7, 0x17,
	0x9b, 0x5d, 0x53, 0xb5, 0x35, 0xbd, 0xc3, 0x27, 0x4f, 0xcd, 0x9e, 0x72, 0xe5, 0x9b, 0xe1, 0x88,
	0x8b, 0xa7, 0x10, 0x4d, 0x62, 0xed, 0x99, 0x9a, 0x61, 0xeb, 0xa6, 0x03, 0xb9, 0x74, 0x0a, 0xd2,
	0x26, 0xb6, 0xba, 0x68, 0x6b, 0x6d, 0x62, 0xd9, 0x6a, 0xdb, 0x09, 0x74, 0xea, 0xfc, 0x81, 0x7e,
	0xa0, 0xb3, 0x9f, 0x8b, 0xf4, 0x17, 0x7f, 0x2b, 0x7d, 0x8b, 0x60, 0xbc, 0x7e, 0xa4, 0x59, 0xb6,
	0xa5, 0x90, 0x4f, 0xbb, 0xc4, 0xb2, 0xf1, 0x5d, 0x28, 0x7c, 0x4c, 0xd4, 0x26, 0x31, 0xab, 0x68,
	0x16, 0xcd, 0x95, 0x96, 0x66, 0xe4, 0x53, 0x19, 0x3a, 0xd0, 0x06, 0x83, 0xd5, 0x8a, 0x9f, 0xfd,
	0x7a, 0x01, 0xbd, 0x78, 0x35, 0x93, 0x51, 0x9c, 0x89, 0xb8, 0x01, 0x79, 0xad, 0x63, 0x74, 0xed,
	0xea, 0x08, 0xb3, 0x30, 0x27, 0xf7, 0x58, 0x23, 0x99, 0x7b, 0x5f, 0xa3, 0xf8, 0x5a, 0xf1, 0x4b,
	0xd7, 0x14, 0x37, 0x20, 0xcd, 0x40, 0x49, 0x18, 0xc7, 0x15, 0xc8, 0x7e, 0x42, 0x8e, 0x59, 0x60,
	0x63, 0x0a, 0xfd, 0x29, 0xfd, 0x80, 0x60, 0xc2, 0x8d, 0xdf, 0x32, 0xf4, 0x8e, 0x45, 0x70, 0x2d,
	0x94, 0xc0, 0xec, 0x59, 0x09, 0x70, 0x6c, 0x64, 0x06, 0xeb, 0x50, 0xd0, 0xbb, 0xb6, 0x9f, 0xc2,
	0x7c, 0x82, 0x14, 0xb6, 0xd9, 0x84, 0x5a, 0xf1, 0x89, 0x67, 0x8c, 0x9b, 0x90, 0xde, 0x82, 0xb2,
	0x88, 0xc0, 0x17, 0xa1, 0xbc, 0xa7, 0x77, 0x6c, 0x55, 0xeb, 0x58, 0x0f, 0xdd, 0x74, 0x8a, 0x4a,
	0xc9, 0x7d, 0xb7, 0x4e, 0x8e, 0xa5, 0xa7, 0x08, 0x4a, 0xf7, 0xb5, 0xc7, 0x64, 0x80, 0xa4, 0xdc,
	0x0b, 0x92, 0x72, 0xb9, 0x67, 0x46, 0xd4, 0x77, 0x04, 0x25, 0x25, 0x18, 0xf3, 0x46, 0xa5, 0x67,
	0x08, 0xca, 0x3c, 0xce, 0x01, 0x2e, 0xfe, 0x5a, 0x68, 0xf1, 0xaf, 0xc4, 0x86, 0x1a, 0xb9, 0xf4,
	0xb3, 0x00, 0xfe, 0x38, 0xc6, 0x90, 0xb3, 0xb4, 0xc7, 0x84, 0x85, 0x36, 0xae, 0xb0, 0xdf, 0xd2,
	0x57, 0x08, 0x60, 0xa7, 0x6b, 0x0f, 0x70, 0xa1, 0xeb, 0xc1, 0x85, 0xbe, 0xd4, 0x33, 0xfa, 0x9d,
	0xae, 0x1d, 0xb1, 0xce, 0x04, 0x8a, 0xee, 0x20, 0xbe, 0x03, 0x79, 0xd2, 0xb1, 0xcd, 0x63, 0x27,
	0x28, 0xa9, 0xf7, 0x6e, 0xa4, 0xc8, 0x5a, 0x8e, 0xdb, 0x62, 0xd3, 0xf0, 0x05, 0x28, 0x6a, 0xfb,
	0x0f, 0x49, 0xdb, 0xb0, 0x8f, 0x59, 0x54, 0x45, 0x65, 0x54, 0xdb, 0xaf, 0xd3, 0x47, 0xe9, 0x1b,
	0x04, 0x25, 0x96, 0xff, 0x00, 0x09, 0x6c, 0x84, 0x08, 0xbc, 0x1c, 0xb7, 0x04, 0x91, 0xfc, 0xd5,
	0x61, 0xcc, 0x1b, 0xc6, 0x37, 0x53, 0xaf, 0x82, 0x93, 0x3f, 0x23, 0x79, 0x95, 0x0c, 0x8d, 0xe4,
	0x55, 0x12, 0x45, 0xf2, 0x12, 0x14, 0xdd, 0x41, 0x7c, 0x9e, 0x9a, 0x6c, 0x92, 0x23, 0x16, 0x54,
	0x4e, 0xe1, 0x0f, 0xae, 0xe4, 0x8d, 0xf8, 0x92, 0x47, 0x19, 0x63, 0xc9, 0x0c, 0x8d, 0xb1, 0x55,
	0xd2, 0x93, 0x31, 0x6f, 0xb8, 0x0f, 0xc6, 0x7e, 0x42, 0x70, 0xee, 0x9e, 0x66, 0x5a, 0x36, 0x7f,
	0x3b, 0x38, 0xe2, 0x36, 0x82, 0xc4, 0x2d, 0xf4, 0x0c, 0xc9, 0x8f, 0x20, 0x82, 0xbf, 0x73, 0x30,
	0x19, 0xc2, 0x48, 0xbf, 0x20, 0xc0, 0x62, 0xe4, 0x03, 0x64, 0x69, 0x3b, 0xc4, 0xd2, 0xf5, 0x84,
	0xc1, 0x47, 0x92, 0xb5, 0x01, 0x95, 0x30, 0xaa, 0x0f, 0xce, 0x9e, 0x23, 0xa8, 0x6c, 0xa8, 0x83,
	0xa7, 0x6c, 0x3d, 0x48, 0xd9, 0xb5, 0x9e, 0x11, 0x79, 0x01, 0x44, 0x30, 0x56, 0x81, 0x89, 0x20,
	0x44, 0xfa, 0x19, 0xc1, 0x39, 0x21, 0xec, 0x01, 0xf2, 0xb5, 0x15, 0xe2, 0x6b, 0x21, 0x59, 0xe4,
	0x91, 0x74, 0xad, 0xc3, 0x64, 0x08, 0xd4, 0x27, 0x5b, 0x3b, 0x26, 0x39, 0x1c, 0x2a, 0x5b, 0x5e,
	0x00, 0x11, 0x6c, 0x5d, 0x86, 0x89, 0x20, 0xe4, 0x6c, 0x95, 0x64, 0x1c, 0x0a, 0xc9, 0x0c, 0x8d,
	0x43, 0x2f, 0x86, 0x5e, 0x1c, 0x86, 0x40, 0x7d, 0x72, 0xb8, 0x45, 0x8e, 0x86, 0x7b, 0xe2, 0xbc,
	0x00, 0xa2, 0x39, 0x0c, 0x42, 0x7a, 0x70, 0x28, 0x24, 0x33, 0x34, 0x0e, 0xbd, 0x18, 0x7a, 0x71,
	0x18, 0x02, 0xf5, 0xc1, 0x21, 0xad, 0xc0, 0x14, 0xd2, 0xd6, 0x0f, 0xc9, 0xb0, 0x2a, 0x30, 0xee,
	0x3d, 0x82, 0xbd, 0x2e, 0x94, 0x84, 0xf1, 0xa4, 0x97, 0x14, 0x7c, 0x07, 0xc6, 0xbc, 0x02, 0xb4,
	0x9a, 0x8d, 0x62, 0x8e, 0x16, 0xaa, 0xf2, 0xae, 0x8b, 0x53, 0xfc, 0x29, 0xac, 0xae, 0x73, 0x57,
	0x65, 0x68, 0x75, 0x1d, 0x0f, 0x20, 0x72, 0x1b, 0x34, 0xa0, 0x2c, 0x22, 0xfa, 0xd8, 0x03, 0x5f,
	0x23, 0x28, 0x2f, 0xb7, 0x88, 0x6a, 0x0e, 0x70, 0x0b, 0xac, 0x06, 0xb7, 0x40, 0xef, 0x22, 0x8a,
	0x39, 0x8f, 0xd8, 0x01, 0x65, 0x00, 0x7f, 0x58, 0xfa, 0x1e, 0xc1, 0xb8, 0x13, 0xea, 0x00, 0x79,
	0xf9, 0x20, 0xc4, 0xcb, 0x5c, 0x7c, 0xb4, 0x91, 0xb4, 0x8c, 0x43, 0x49, 0x00, 0x48, 0xdf, 0x21,
	0x98, 0xa0, 0x8b, 0xad, 0x91, 0x41, 0xb6, 0x38, 0xd6, 0x82, 0xab, 0x3b, 0x1f, 0xcb, 0xb5, 0x46,
	0xa2, 0x7a, 0x1c, 0x13, 0x50, 0x16, 0x01, 0xd2, 0x8f, 0x08, 0x26, 0xbd, 0x80, 0x07, 0xb8, 0xc6,
	0x1b, 0xa1, 0x35, 0xbe, 0x9a, 0x24, 0xe6, 0xc8, 0x55, 0xde, 0x86, 0xf1, 0x00, 0xa4, 0xdf, 0x1a,
	0x95, 0x77, 0xa2, 0x0e, 0x49, 0x67, 0x88, 0x9d, 0x28, 0xe6, 0x3d, 0x82, 0xa5, 0x26, 0x94, 0x84,
	0x71, 0x7c, 0x1b, 0xb2, 0x86, 0x6e, 0x39, 0x81, 0xc5, 0x94, 0xf8, 0xba, 0xa5, 0xd9, 0x9a, 0xde,
	0x71, 0xd2, 0xa5, 0xf3, 0xf0, 0x1b, 0x50, 0x30, 0x89, 0xd1, 0x52, 0xdd, 0x72, 0xdc, 0x79, 0xe2,
	0xed, 0x2c, 0x67, 0x11, 0x86, 0xd7, 0xce, 0x62, 0x01, 0x44, 0x32, 0xff, 0x3b, 0x82, 0xb2, 0x08,
	0xc1, 0x35, 0xc8, 0xd9, 0xc7, 0x06, 0x6f, 0xab, 0x4c, 0x2c, 0xc9, 0x89, 0x6d, 0xcb, 0xbb, 0xc7,
	0x06, 0x51, 0xd8, 0x5c, 0x7f, 0xf7, 0x8c, 0xfc, 0xbf, 0xdd, 0x73, 0x13, 0x72, 0xd4, 0x1a, 0x2e,
	0x42, 0x6e, 0x6b, 0x7b, 0xab, 0x5e, 0xc9, 0xe0, 0x32, 0x14, 0xd7, 0xb6, 0xee, 0xd7, 0x95, 0xdd,
	0xfa, 0x4a, 0x05, 0xe1, 0x12, 0x8c, 0x7e, 0xb8, 0xb3, 0x72, 0x97, 0x3e, 0x8c, 0xd0, 0x07, 0xa5,
	0xbe, 0xb9, 0xfd, 0xa0, 0xbe, 0x52, 0xc9, 0xd2, 0x12, 0xdc, 0x65, 0x28, 0x71, 0x09, 0xfe, 0x05,
	0x82, 0x3c, 0x0b, 0xa2, 0xdf, 0x7d, 0x70, 0x07, 0xf2, 0x87, 0x6a, 0xab, 0x4b, 0x12, 0xa5, 0xfd,
	0x80, 0x22, 0xdd, 0xb4, 0xd9, 0x34, 0xe9, 0x19, 0x82, 0x3c, 0x7b, 0x4d, 0x43, 0xe7, 0x96, 0x68,
	0x28, 0x65, 0x67, 0x1c, 0xaf, 0x88, 0x9f, 0xe1, 0x91, 0x64, 0x9f, 0x61, 0xc7, 0x83, 0x3f, 0x11,
	0xdf, 0x84, 0xac, 0x6d, 0xb7, 0x9c, 0xcf, 0xf8, 0x05, 0x99, 0x37, 0xb5, 0x65, 0xb7, 0xa9, 0x2d,
	0xaf, 0x38, 0x4d, 0xed, 0x5a, 0xe9, 0xe4, 0xd5, 0x4c, 0x76, 0x77, 0x77, 0xe3, 0xe9, 0x5f, 0x33,
	0x48, 0xa1, 0x53, 0x58, 0x19, 0xbf, 0xc6, 0x33, 0xd8, 0x54, 0x8d, 0x61, 0x95, 0xf1, 0x7e, 0x04,
	0x11, 0x87, 0xfb, 0xcf, 0x02, 0x4c, 0x86, 0x40, 0xf8, 0x5d, 0xa1, 0x59, 0x98, 0xb8, 0x5d, 0xda,
	0xc8, 0xf0, 0xb6, 0x22, 0x3d, 0xb5, 0x84, 0xf5, 0x7c, 0xd3, 0xf6, 0xc0, 0x1b, 0x19, 0xc5, 0x99,
	0x89, 0xdf, 0x81, 0x2c, 0xcd, 0x30, 0x9b, 0xa2, 0x8d, 0xd8, 0xa0, 0xfb, 0xaa, 0x6b, 0xd3, 0xa9,
	0x07, 0xc4, 0xae, 0xe6, 0x52, 0x34, 0xa7, 0xe8, 0xd4, 0x03, 0x62, 0xe3, 0x6d, 0x28, 0xed, 0x6b,
	0xa6, 0x65, 0x3f, 0xe4, 0xe7, 0x31, 0x9f, 0xbe, 0x4d, 0xd2, 0xc8, 0x28, 0xb0, 0xef, 0xbd, 0xc2,
	0x1b, 0x00, 0x2d, 0xd5, 0xb3, 0x57, 0x48, 0x5d, 0xc3, 0x37, 0x32, 0xca, 0x58, 0x4b, 0x15, 0xac,
	0x19, 0x26, 0x39, 0x74, 0xac, 0x8d, 0xa6, 0xae, 0x31, 0xa9, 0x35, 0xc3, 0x7d, 0x43, 0xad, 0x75,
	0xc8, 0x91, 0x1b, 0x5b, 0x31, 0x75, 0xb5, 0x43, 0xad, 0x75, 0xdc, 0x37, 0x94, 0x74, 0x93, 0x5d,
	0x08, 0xab, 0x63, 0xe9, 0xae, 0xdd, 0x94, 0x74, 0x3e, 0x13, 0xbf, 0x07, 0xf9, 0x3d, 0x7a, 0x7b,
	0xa9, 0x42, 0xaa, 0x6b, 0x5b, 0x23, 0xa3, 0xf0, 0x79, 0x6c, 0xe7, 0x31, 0x91, 0xad, 0x96, 0xd2,
	0x7d, 0xf3, 0xd8, 0xce, 0x63, 0x8f, 0xb8, 0x0e, 0xa3, 0x84, 0x7f, 0xdc, 0xab, 0xe5, 0x94, 0xf7,
	0x9b, 0x46, 0x46, 0x71, 0xe7, 0xd6, 0x46, 0x9d, 0x43, 0xca, 0x7a, 0x62, 0xa2, 0x0c, 0x0c, 0xad,
	0x27, 0xe6, 0x07, 0x11, 0xf9, 0x79, 0xfb, 0xa7, 0x00, 0x95, 0x30, 0x0c, 0xdf, 0x0e, 0x88, 0x41,
	0xd2, 0x3f, 0x24, 0x3c, 0x35, 0x58, 0x0e, 0xa9, 0x41, 0xf2, 0xbf, 0x93, 0x04, 0x39, 0xb8, 0x25,
	0xca, 0x41, 0xc2, 0x96, 0xba, 0xab, 0x07, 0xb7, 0x44, 0x3d, 0x48, 0xd8, 0xdc, 0x75, 0x05, 0x61,
	0xe7, 0x2c, 0x41, 0x48, 0xd7, 0x7a, 0x0c, 0x29, 0xc2, 0xe6, 0x19, 0x8a, 0x90, 0xaa, 0x37, 0x16,
	0x94, 0x84, 0xcd, 0x33, 0x24, 0x21, 0x55, 0x9b, 0x26, 0xa8, 0x09, 0x9b, 0x67, 0x68, 0x42, 0xaa,
	0x8e, 0x41, 0x50, 0x14, 0x96, 0x43, 0xa2, 0x90, 0xbc, 0xe4, 0x14, 0x54, 0xe1, 0xfd, 0xa0, 0x2a,
	0x24, 0x2e, 0x8f, 0x7c, 0x59, 0x58, 0x0e, 0xc9, 0x42, 0xf2, 0x2b, 0xa0, 0xa0, 0x0b, 0xf7, 0xc2,
	0xba, 0x90, 0xa2, 0x86, 0x10, 0x85, 0xa1, 0xe8, 0x1e, 0xda, 0xa5, 0xe7, 0x20, 0x5e, 0x10, 0xee,
	0x13, 0xf3, 0x50, 0xdb, 0x23, 0x58, 0x85, 0x1c, 0x3d, 0x45, 0x78, 0x2e, 0xf6, 0xa0, 0x39, 0xf7,
	0x84, 0xa9, 0xf9, 0x04, 0x48, 0xae, 0x24, 0x52, 0xee, 0xc5, 0xbf, 0x55, 0x84, 0x0f, 0xa0, 0xc0,
	0xcf, 0x19, 0xbe, 0x9a, 0xe0, 0x30, 0xba, 0x6e, 0xae, 0x25, 0xc2, 0x06, 0x1c, 0x7d, 0x04, 0xd9,
	0x9d, 0xae, 0x8d, 0xaf, 0xc4, 0x1d, 0x58, 0xd7, 0xc5, 0x5c, 0x3c, 0x50, 0xb0, 0x9f, 0xa1, 0xf6,
	0x57, 0x49, 0x9c, 0x7d, 0xff, 0xcf, 0xaf, 0x18, 0xfb, 0xc2, 0x1f, 0x4b, 0x4e, 0xfc, 0x16, 0x80,
	0x7f, 0x9c, 0xb1, 0x9c, 0xf0, 0xdc, 0xbb, 0xde, 0x16, 0x13, 0xe3, 0x03, 0x4e, 0x0d, 0x18, 0xf3,
	0x8e, 0x3c, 0xbe, 0x9e, 0x4c, 0x1a, 0x5c, 0x97, 0x72, 0x52, 0x78, 0xd8, 0xa3, 0xa7, 0x0a, 0x31,
	0x1e, 0xc3, 0x5d, 0xf3, 0x18, 0x8f, 0xa7, 0xfa, 0xd2, 0xbe, 0x47, 0x4f, 0x38, 0x62, 0x3c, 0x86,
	0x7b, 0xbc, 0x31, 0x1e, 0x4f, 0x75, 0x51, 0xfd, 0x3d, 0xcf, 0xf5, 0x25, 0x66, 0xcf, 0x07, 0xda,
	0x91, 0x31, 0x7b, 0x3e, 0xd8, 0xa4, 0x73, 0xf6, 0x64, 0x13, 0xf2, 0x4c, 0x84, 0xf0, 0x7c, 0xbc,
	0x50, 0xb9, 0x6e, 0xae, 0x26, 0x81, 0x06, 0xbc, 0x68, 0x50, 0xe0, 0x3a, 0x15, 0x77, 0x84, 0xc5,
	0xae, 0x42, 0xdc, 0x11, 0x0e, 0x14, 0xdf, 0xdc, 0xd1, 0x0d, 0x84, 0x5b, 0x30, 0xea, 0x88, 0x19,
	0xbe, 0x96, 0x44, 0xf2, 0x5c, 0x67, 0x0b, 0xc9, 0xc0, 0x22, 0x4b, 0x37, 0xd0, 0xd4, 0xc4, 0xe7,
	0xbf, 0x55, 0xc1, 0x57, 0xc5, 0x5a, 0xf5, 0xc5, 0xc9, 0x34, 0x7a, 0x79, 0x32, 0x8d, 0xfe, 0x3e,
	0x99, 0x46, 0x4f, 0x5e, 0x4f, 0x67, 0x5e, 0xbe, 0x9e, 0xce, 0xfc, 0xf1, 0x7a, 0x3a, 0xf3, 0xa8,
	0xc0, 0x8a, 0xb0, 0xb7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x7c, 0x10, 0x7f, 0x3a, 0xb4, 0x24,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IndexedMapServiceClient is the client API for IndexedMapService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IndexedMapServiceClient interface {
	// Size returns the size of the map
	Size(ctx context.Context, in *SizeRequest, opts ...grpc.CallOption) (*SizeResponse, error)
	// Exists checks whether a key exists in the map
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
	// Put puts an entry into the map
	Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error)
	// Get gets the entry for a key
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// FirstEntry gets the first entry in the map
	FirstEntry(ctx context.Context, in *FirstEntryRequest, opts ...grpc.CallOption) (*FirstEntryResponse, error)
	// LastEntry gets the last entry in the map
	LastEntry(ctx context.Context, in *LastEntryRequest, opts ...grpc.CallOption) (*LastEntryResponse, error)
	// PrevEntry gets the previous entry in the map
	PrevEntry(ctx context.Context, in *PrevEntryRequest, opts ...grpc.CallOption) (*PrevEntryResponse, error)
	// NextEntry gets the next entry in the map
	NextEntry(ctx context.Context, in *NextEntryRequest, opts ...grpc.CallOption) (*NextEntryResponse, error)
	// Remove removes an entry from the map
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	// Clear removes all entries from the map
	Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error)
	// Events listens for change events
	Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (IndexedMapService_EventsClient, error)
	// Entries lists all entries in the map
	Entries(ctx context.Context, in *EntriesRequest, opts ...grpc.CallOption) (IndexedMapService_EntriesClient, error)
}

type indexedMapServiceClient struct {
	cc *grpc.ClientConn
}

func NewIndexedMapServiceClient(cc *grpc.ClientConn) IndexedMapServiceClient {
	return &indexedMapServiceClient{cc}
}

func (c *indexedMapServiceClient) Size(ctx context.Context, in *SizeRequest, opts ...grpc.CallOption) (*SizeResponse, error) {
	out := new(SizeResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/Size", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) {
	out := new(ExistsResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/Exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error) {
	out := new(PutResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) FirstEntry(ctx context.Context, in *FirstEntryRequest, opts ...grpc.CallOption) (*FirstEntryResponse, error) {
	out := new(FirstEntryResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/FirstEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) LastEntry(ctx context.Context, in *LastEntryRequest, opts ...grpc.CallOption) (*LastEntryResponse, error) {
	out := new(LastEntryResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/LastEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) PrevEntry(ctx context.Context, in *PrevEntryRequest, opts ...grpc.CallOption) (*PrevEntryResponse, error) {
	out := new(PrevEntryResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/PrevEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) NextEntry(ctx context.Context, in *NextEntryRequest, opts ...grpc.CallOption) (*NextEntryResponse, error) {
	out := new(NextEntryResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/NextEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error) {
	out := new(ClearResponse)
	err := c.cc.Invoke(ctx, "/atomix.primitive.indexedmap.IndexedMapService/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexedMapServiceClient) Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (IndexedMapService_EventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IndexedMapService_serviceDesc.Streams[0], "/atomix.primitive.indexedmap.IndexedMapService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &indexedMapServiceEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IndexedMapService_EventsClient interface {
	Recv() (*EventsResponse, error)
	grpc.ClientStream
}

type indexedMapServiceEventsClient struct {
	grpc.ClientStream
}

func (x *indexedMapServiceEventsClient) Recv() (*EventsResponse, error) {
	m := new(EventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *indexedMapServiceClient) Entries(ctx context.Context, in *EntriesRequest, opts ...grpc.CallOption) (IndexedMapService_EntriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IndexedMapService_serviceDesc.Streams[1], "/atomix.primitive.indexedmap.IndexedMapService/Entries", opts...)
	if err != nil {
		return nil, err
	}
	x := &indexedMapServiceEntriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IndexedMapService_EntriesClient interface {
	Recv() (*EntriesResponse, error)
	grpc.ClientStream
}

type indexedMapServiceEntriesClient struct {
	grpc.ClientStream
}

func (x *indexedMapServiceEntriesClient) Recv() (*EntriesResponse, error) {
	m := new(EntriesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IndexedMapServiceServer is the server API for IndexedMapService service.
type IndexedMapServiceServer interface {
	// Size returns the size of the map
	Size(context.Context, *SizeRequest) (*SizeResponse, error)
	// Exists checks whether a key exists in the map
	Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
	// Put puts an entry into the map
	Put(context.Context, *PutRequest) (*PutResponse, error)
	// Get gets the entry for a key
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// FirstEntry gets the first entry in the map
	FirstEntry(context.Context, *FirstEntryRequest) (*FirstEntryResponse, error)
	// LastEntry gets the last entry in the map
	LastEntry(context.Context, *LastEntryRequest) (*LastEntryResponse, error)
	// PrevEntry gets the previous entry in the map
	PrevEntry(context.Context, *PrevEntryRequest) (*PrevEntryResponse, error)
	// NextEntry gets the next entry in the map
	NextEntry(context.Context, *NextEntryRequest) (*NextEntryResponse, error)
	// Remove removes an entry from the map
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	// Clear removes all entries from the map
	Clear(context.Context, *ClearRequest) (*ClearResponse, error)
	// Events listens for change events
	Events(*EventsRequest, IndexedMapService_EventsServer) error
	// Entries lists all entries in the map
	Entries(*EntriesRequest, IndexedMapService_EntriesServer) error
}

// UnimplementedIndexedMapServiceServer can be embedded to have forward compatible implementations.
type UnimplementedIndexedMapServiceServer struct {
}

func (*UnimplementedIndexedMapServiceServer) Size(ctx context.Context, req *SizeRequest) (*SizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Size not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Exists(ctx context.Context, req *ExistsRequest) (*ExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Put(ctx context.Context, req *PutRequest) (*PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedIndexedMapServiceServer) FirstEntry(ctx context.Context, req *FirstEntryRequest) (*FirstEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FirstEntry not implemented")
}
func (*UnimplementedIndexedMapServiceServer) LastEntry(ctx context.Context, req *LastEntryRequest) (*LastEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LastEntry not implemented")
}
func (*UnimplementedIndexedMapServiceServer) PrevEntry(ctx context.Context, req *PrevEntryRequest) (*PrevEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrevEntry not implemented")
}
func (*UnimplementedIndexedMapServiceServer) NextEntry(ctx context.Context, req *NextEntryRequest) (*NextEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextEntry not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Remove(ctx context.Context, req *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Clear(ctx context.Context, req *ClearRequest) (*ClearResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Events(req *EventsRequest, srv IndexedMapService_EventsServer) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (*UnimplementedIndexedMapServiceServer) Entries(req *EntriesRequest, srv IndexedMapService_EntriesServer) error {
	return status.Errorf(codes.Unimplemented, "method Entries not implemented")
}

func RegisterIndexedMapServiceServer(s *grpc.Server, srv IndexedMapServiceServer) {
	s.RegisterService(&_IndexedMapService_serviceDesc, srv)
}

func _IndexedMapService_Size_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).Size(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/Size",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).Size(ctx, req.(*SizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/Exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).Exists(ctx, req.(*ExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).Put(ctx, req.(*PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_FirstEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirstEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).FirstEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/FirstEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).FirstEntry(ctx, req.(*FirstEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_LastEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).LastEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/LastEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).LastEntry(ctx, req.(*LastEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_PrevEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrevEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).PrevEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/PrevEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).PrevEntry(ctx, req.(*PrevEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_NextEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).NextEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/NextEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).NextEntry(ctx, req.(*NextEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexedMapServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.primitive.indexedmap.IndexedMapService/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexedMapServiceServer).Clear(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexedMapService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexedMapServiceServer).Events(m, &indexedMapServiceEventsServer{stream})
}

type IndexedMapService_EventsServer interface {
	Send(*EventsResponse) error
	grpc.ServerStream
}

type indexedMapServiceEventsServer struct {
	grpc.ServerStream
}

func (x *indexedMapServiceEventsServer) Send(m *EventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _IndexedMapService_Entries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EntriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexedMapServiceServer).Entries(m, &indexedMapServiceEntriesServer{stream})
}

type IndexedMapService_EntriesServer interface {
	Send(*EntriesResponse) error
	grpc.ServerStream
}

type indexedMapServiceEntriesServer struct {
	grpc.ServerStream
}

func (x *indexedMapServiceEntriesServer) Send(m *EntriesResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _IndexedMapService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atomix.primitive.indexedmap.IndexedMapService",
	HandlerType: (*IndexedMapServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Size",
			Handler:    _IndexedMapService_Size_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _IndexedMapService_Exists_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _IndexedMapService_Put_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _IndexedMapService_Get_Handler,
		},
		{
			MethodName: "FirstEntry",
			Handler:    _IndexedMapService_FirstEntry_Handler,
		},
		{
			MethodName: "LastEntry",
			Handler:    _IndexedMapService_LastEntry_Handler,
		},
		{
			MethodName: "PrevEntry",
			Handler:    _IndexedMapService_PrevEntry_Handler,
		},
		{
			MethodName: "NextEntry",
			Handler:    _IndexedMapService_NextEntry_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _IndexedMapService_Remove_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _IndexedMapService_Clear_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _IndexedMapService_Events_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Entries",
			Handler:       _IndexedMapService_Entries_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "atomix/primitive/indexedmap/indexedmap.proto",
}

func (m *ExistsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExistsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExistsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExistsInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExistsInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExistsInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIndexedmap(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExistsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExistsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExistsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExistsOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExistsOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExistsOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContainsKey {
		i--
		if m.ContainsKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SizeInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SizeOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IfEmpty {
		i--
		if m.IfEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIndexedmap(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FirstEntryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstEntryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirstEntryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FirstEntryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstEntryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirstEntryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FirstEntryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstEntryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirstEntryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FirstEntryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstEntryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirstEntryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LastEntryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastEntryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastEntryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LastEntryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastEntryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastEntryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LastEntryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastEntryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastEntryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LastEntryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastEntryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastEntryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrevEntryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrevEntryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrevEntryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PrevEntryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrevEntryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrevEntryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrevEntryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrevEntryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrevEntryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PrevEntryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrevEntryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrevEntryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextEntryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextEntryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextEntryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NextEntryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextEntryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextEntryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NextEntryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextEntryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextEntryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NextEntryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextEntryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextEntryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemoveInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIndexedmap(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemoveOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClearResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EntriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EntriesInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EntriesOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventsInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Replay {
		i--
		if m.Replay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventsOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIndexedmap(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintIndexedmap(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		n63, err63 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL):])
		if err63 != nil {
			return 0, err63
		}
		i -= n63
		i = encodeVarintIndexedmap(dAtA, i, uint64(n63))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIndexedmap(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexedMapRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexedMapRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexedMapInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexedMapInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IndexedMapInput_Size_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Size_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Exists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Exists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exists != nil {
		{
			size, err := m.Exists.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Put) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Put) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_FirstEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_FirstEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FirstEntry != nil {
		{
			size, err := m.FirstEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_LastEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_LastEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LastEntry != nil {
		{
			size, err := m.LastEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_PrevEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_PrevEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrevEntry != nil {
		{
			size, err := m.PrevEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_NextEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_NextEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NextEntry != nil {
		{
			size, err := m.NextEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Remove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Remove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Remove != nil {
		{
			size, err := m.Remove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Clear) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Clear) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Clear != nil {
		{
			size, err := m.Clear.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapInput_Entries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapInput_Entries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexedMapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexedmap(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexedMapOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexedMapOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IndexedMapOutput_Size_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Size_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Exists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Exists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exists != nil {
		{
			size, err := m.Exists.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Put) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Put) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_FirstEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_FirstEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FirstEntry != nil {
		{
			size, err := m.FirstEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_LastEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_LastEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LastEntry != nil {
		{
			size, err := m.LastEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_PrevEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_PrevEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrevEntry != nil {
		{
			size, err := m.PrevEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_NextEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_NextEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NextEntry != nil {
		{
			size, err := m.NextEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Remove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Remove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Remove != nil {
		{
			size, err := m.Remove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Clear) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Clear) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Clear != nil {
		{
			size, err := m.Clear.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *IndexedMapOutput_Entries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedMapOutput_Entries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexedmap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func encodeVarintIndexedmap(dAtA []byte, offset int, v uint64) int {
	offset -= sovIndexedmap(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ExistsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *ExistsInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *ExistsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *ExistsOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainsKey {
		n += 2
	}
	return n
}

func (m *SizeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *SizeInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SizeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *SizeOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovIndexedmap(uint64(m.Size_))
	}
	return n
}

func (m *PutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *PutInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	if m.IfEmpty {
		n += 2
	}
	return n
}

func (m *PutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *PutOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *GetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIndexedmap(uint64(m.Index))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *GetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *FirstEntryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *FirstEntryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FirstEntryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *FirstEntryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *LastEntryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *LastEntryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LastEntryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *LastEntryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *PrevEntryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *PrevEntryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIndexedmap(uint64(m.Index))
	}
	return n
}

func (m *PrevEntryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *PrevEntryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *NextEntryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *NextEntryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIndexedmap(uint64(m.Index))
	}
	return n
}

func (m *NextEntryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *NextEntryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *RemoveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *RemoveInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIndexedmap(uint64(m.Index))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *RemoveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *RemoveOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *ClearRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *ClearInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClearResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *ClearOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EntriesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *EntriesInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EntriesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *EntriesOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *EventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *EventsInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pos.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	if m.Replay {
		n += 2
	}
	return n
}

func (m *EventsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *EventsOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovIndexedmap(uint64(m.Type))
	}
	l = m.Entry.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIndexedmap(uint64(m.Index))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pos.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	if m.TTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL)
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func (m *IndexedMapRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Input.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *IndexedMapInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *IndexedMapInput_Size_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Exists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists != nil {
		l = m.Exists.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_FirstEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FirstEntry != nil {
		l = m.FirstEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_LastEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastEntry != nil {
		l = m.LastEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_PrevEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevEntry != nil {
		l = m.PrevEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_NextEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextEntry != nil {
		l = m.NextEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Remove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remove != nil {
		l = m.Remove.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Clear) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear != nil {
		l = m.Clear.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapInput_Entries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	l = m.Output.Size()
	n += 1 + l + sovIndexedmap(uint64(l))
	return n
}

func (m *IndexedMapOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *IndexedMapOutput_Size_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Exists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists != nil {
		l = m.Exists.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_FirstEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FirstEntry != nil {
		l = m.FirstEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_LastEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastEntry != nil {
		l = m.LastEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_PrevEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevEntry != nil {
		l = m.PrevEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_NextEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextEntry != nil {
		l = m.NextEntry.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Remove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remove != nil {
		l = m.Remove.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Clear) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear != nil {
		l = m.Clear.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}
func (m *IndexedMapOutput_Entries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovIndexedmap(uint64(l))
	}
	return n
}

func sovIndexedmap(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIndexedmap(x uint64) (n int) {
	return sovIndexedmap(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExistsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExistsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExistsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExistsInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExistsInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExistsInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExistsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExistsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExistsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExistsOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExistsOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExistsOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfEmpty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstEntryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstEntryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstEntryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstEntryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstEntryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstEntryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstEntryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstEntryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstEntryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstEntryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastEntryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastEntryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastEntryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastEntryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastEntryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastEntryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastEntryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastEntryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastEntryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastEntryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrevEntryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrevEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrevEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrevEntryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrevEntryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrevEntryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrevEntryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrevEntryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrevEntryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrevEntryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrevEntryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrevEntryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextEntryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextEntryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextEntryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextEntryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextEntryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextEntryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextEntryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextEntryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextEntryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextEntryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &meta.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &Entry{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntriesInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntriesOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EventsOutput_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexedMapRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedMapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedMapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexedMapInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedMapInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedMapInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SizeInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Size_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExistsInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Exists{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PutInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Put{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Get{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FirstEntryInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_FirstEntry{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LastEntryInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_LastEntry{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrevEntryInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_PrevEntry{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NextEntryInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_NextEntry{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Remove{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Clear{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Events{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EntriesInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &IndexedMapInput_Entries{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexedMapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedMapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedMapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexedMapOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedMapOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedMapOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SizeOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Size_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExistsOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Exists{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PutOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Put{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Get{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FirstEntryOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_FirstEntry{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LastEntryOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_LastEntry{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrevEntryOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_PrevEntry{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NextEntryOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_NextEntry{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Remove{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Clear{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Events{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexedmap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EntriesOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &IndexedMapOutput_Entries{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexedmap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIndexedmap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIndexedmap(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIndexedmap
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexedmap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIndexedmap
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIndexedmap
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIndexedmap
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIndexedmap        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIndexedmap          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIndexedmap = fmt.Errorf("proto: unexpected end of group")
)
